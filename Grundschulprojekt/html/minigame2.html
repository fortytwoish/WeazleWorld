<style>
	#minigame2{
		width: 100%;
		height: 100%;
	}

	/* testen 880 x 520 */

	#minigame2 #canvas{
		width: 100%;
		height: 100%;
		background-color: #AAA;
	}
</style>
<div id="minigame2">
	<button id="winMinigameButton" style="margin:auto">Win</button>
	<button id="loseMinigameButton" style="margin: auto">Lose</button>
	<canvas id="canvas"></canvas>
</div>
<script type="text/javascript" src="../Resources/jquery-2.2.4.min.js"></script>
<script type="text/javascript" src="../Resources/preloadjs-0.6.2.min.js"></script>
<script type="text/javascript" src="../Resources/easeljs-0.8.2.min.js"></script>
<script type="text/javascript" src="../Resources/tweenjs-0.6.2.min.js"></script>
<button id="exitMinigameButton" style="margin:auto">Exit</button>
<button id="winMinigameButton" style="margin:auto">Win</button>
<button id="loseMinigameButton" style="margin:auto">Lose</button>

<script>
	/*
	*   CONST
	*/

	var DIFFICULTIES = {
		TUT: [3, 3],
		EASY: [4, 4],
		MEDIUM: [5, 4],
		HARD: [7, 5]
	};

	var DEBUG_LEVEL = {
		OFF: 0,
		DEBUG: 1,
		VERBOSE: 2
	};
	var PIPE_TYPES = {
		STRAIGHT: 1,
		CURVE: 2
	};
	var IMAGES = {
		STRAIGHT: "/img/waterGame/STRAIGHT.png",
		CURVE: "/img/waterGame/CURVE.png",
		ROTATE: "/img/waterGame/rotate.gif"
	};

	var DEBUG = DEBUG_LEVEL.VERBOSE;

	var stage = new createjs.Stage("canvas");
	stage.enableMouseOver(10);

	/*
	*   OBJECTS
	*/

	var Pipe = function(type, targetRotation)
	{
		var typeLocal = type;
		var currentRotationLocal = (parseInt(Math.random() * 4) * 90);
		var targetRotationLocal = targetRotation;

		this.getType = function()
		{
			return typeLocal;
		}

		this.getImage = function()
		{
			switch (typeLocal)
			{
				case PIPE_TYPES.CURVE:
					return IMAGES.CURVE;
				case PIPE_TYPES.STRAIGHT:
					return IMAGES.STRAIGHT;
			}
			return IMAGES.ROTATE;
		}

		this.getRotation = function()
		{
			return currentRotationLocal;
		}

		this.isInCorrectPosition = function()
		{
			if (currentRotationLocal === targetRotationLocal ||
				targetRotationLocal === -1 ||
				typeLocal === PIPE_TYPES.STRAIGHT && currentRotationLocal === targetRotationLocal + 180)
				return true;
			return false;
		}

		this.turn = function()
		{
			if (currentRotationLocal < 270)
				currentRotationLocal += 90;
			else
				currentRotationLocal = 0;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("Rotate to: " + currentRotationLocal);
		}
	}

	var PIPES = {
		UPDOWN: new Pipe(PIPE_TYPES.STRAIGHT, 0),
		UPLEFT: new Pipe(PIPE_TYPES.CURVE, 0),
		RIGHTDOWN: new Pipe(PIPE_TYPES.CURVE, 180),
		RIGHTLEFT: new Pipe(PIPE_TYPES.STRAIGHT, 90)
	};

	/*
	*   LOCAL FUNCTIONS
	*/

	var gameFieldConvertToBitmap = function(gameField)
	{
		var orgImgSize = [200, 200];
		var pipeSize = (window.innerHeight - 200) / gameField.length;
		var x = (window.innerWidth / 2) - ((pipeSize * gameField.length) / 2);
		var y = (window.innerHeight / 2) - ((pipeSize * gameField.length) / 2);
		var bitmaps = new Array(gameField.length);

		for (var i = 0; i < gameField.length; i++)
		{
			bitmaps[i] = new Array(gameField[i]);
			for (var j = 0; j < gameField[i].length; j++)
			{
				var bitmap = new createjs.Bitmap(gameField[i][j].getImage());
				bitmap.x = x + (j * pipeSize) + orgImgSize[0] / 2;
				bitmap.y = y + (i * pipeSize) + orgImgSize[1] / 2;
				bitmap.regX = orgImgSize[0] / 2;
				bitmap.regY = orgImgSize[1] / 2;
				bitmap.scaleX = pipeSize / orgImgSize[0];
				bitmap.scaleY = pipeSize / orgImgSize[1];
				bitmap.rotation = gameField[i][j].getRotation();
				bitmap.pipe = gameField[i][j];
				bitmaps[i][j] = bitmap;
			}
		}
		return bitmaps;
	}

	var rotater = new createjs.Bitmap(IMAGES.ROTATE);
	var setListenerToBitmap = function(bitmaps)
	{
		for (var i = 0; i < bitmaps.length; i++)
			for (var j = 0; j < bitmaps[i].length; j++)
			{
				bitmaps[i][j].on("click", function()
				{
					this.pipe.turn();
				});
				bitmaps[i][j].on("mouseover", function()
				{
					this.alpha = 0.5;
					rotater.x = this.x - 50;
					rotater.y = this.y - 50;
					rotater.scaleX = 0.1;
					rotater.scaleY = 0.1;
					stage.addChild(rotater);
				});
				bitmaps[i][j].on("mouseout", function(e)
				{
					this.alpha = 1;
					stage.removeChild(rotater);
				});
			}
	}

	var addBitmapsToStage = function(stage, bitmaps)
	{
		for (var i = 0; i < bitmaps.length; i++)
			for (var j = 0; j < bitmaps[i].length; j++)
				stage.addChild(bitmaps[i][j]);
	}

	var removeBitmapsFromStage = function(stage, bitmaps)
	{
		for (var i = 0; i < bitmaps.length; i++)
			for (var j = 0; j < bitmaps[i].length; j++)
				stage.removeChild(bitmaps[i][j]);
	}

	var generateGameField = function(size)
	{
		// Baut das Array auf
		var gameField = new Array(size[1]);
		for (var i = 0; i < gameField.length; i++)
		{
			gameField[i] = new Array(size[0]);
			for (var j = 0; j < gameField[i].length; j++)
				if (parseInt(Math.random() * 2) === 0)
					gameField[i][j] = new Pipe(PIPE_TYPES.CURVE, -1);
				else
					gameField[i][j] = new Pipe(PIPE_TYPES.STRAIGHT, -1);
		}

		if (DEBUG >= DEBUG_LEVEL.DEBUG)
			console.log("Array aufgebaut");

		// Zufälliger Weg
		if (parseInt(Math.random() * 2) === 0)
		{
			gameField[0][size[0] - 1] = PIPES.RIGHTDOWN;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("RIGHTDOWN " + 0 + " " + (size[0] - 1));
		} else
		{
			gameField[0][size[0] - 1] = PIPES.RIGHTLEFT;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("RIGHTLEFT " + 0 + " " + (size[0] - 1));
		}

		for (var i = 0, j = size[0] - 1; i < gameField.length - 1 || j > 0;)
			switch (gameField[i][j])
			{
				case PIPES.UPDOWN:
					if (i < gameField.length - 2)
						if (parseInt(Math.random() * 2) === 0)
							gameField[++i][j] = PIPES.UPDOWN;
						else
							gameField[++i][j] = PIPES.UPLEFT;
					else
						gameField[++i][j] = PIPES.UPLEFT;
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("UPDOWN " + i + " " + j);
					break;
				case PIPES.UPLEFT:
					if (j > 0)
						if (parseInt(Math.random() * 2) === 0)
							gameField[i][--j] = PIPES.RIGHTDOWN;
						else
							gameField[i][--j] = PIPES.RIGHTLEFT;
					else
						gameField[i][--j] = PIPES.RIGHTLEFT;
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("UPLEFT " + i + " " + j);
					break;
				case PIPES.RIGHTDOWN:
					if (i < gameField.length - 1)
						if (parseInt(Math.random() * 2) === 0)
							gameField[++i][j] = PIPES.UPDOWN;
						else
							gameField[++i][j] = PIPES.UPLEFT;
					else
					{
						console.log("Vor: " + i);
						gameField[++i][j] = PIPES.UPDOWN;
						console.log("Nach: " + i);
					}
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("RIGHTDOWN " + i + " " + j);
					break;
				case PIPES.RIGHTLEFT:
					if (j > 1)
						if (parseInt(Math.random() * 2) === 0)
							gameField[i][--j] = PIPES.RIGHTLEFT;
						else
							gameField[i][--j] = PIPES.RIGHTDOWN;
					else
						gameField[i][--j] = PIPES.RIGHTDOWN;
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("RIGHTLEFT " + i + " " + j);
					break;
			}

		if (DEBUG >= DEBUG_LEVEL.DEBUG)
			console.log("Weg erzeugt");

		// Testausgabe row = zeile
		if (DEBUG >= DEBUG_LEVEL.VERBOSE)
		{
			console.log("Lösung");
			gameField.forEach(function(row)
			{
				var s = '[';
				row.forEach(function(col)
				{
					switch (col)
					{
						case PIPES.UPDOWN:
							s = s + ' ' + "|";
							break;
						case PIPES.UPLEFT:
							s = s + ' ' + "L";
							break;
						case PIPES.RIGHTDOWN:
							s = s + ' ' + "D";
							break;
						case PIPES.RIGHTLEFT:
							s = s + ' ' + "-";
							break;
						default:
							s = s + ' ' + " ";
							break;
					}
				});
				console.log(s + ' ]');
			});
		}

		return gameField;
	}

	var check = function(gameField)
	{
		for (var i = 0; i < gameField.length; i++)
			for (var j = 0; j < gameField[i].length; j++)
				if (!gameField[i][j].isInCorrectPosition())
					return false;
		return true;
	}

	var generateButton = function(text, name)
	{
		var messageButtonBackground = new createjs.Shape();
		messageButtonBackground.graphics.beginFill("Red").drawRoundRect(0, 0, 100, 60, 10);

		var messageButtonText = new createjs.Text(text, "bold 24px Arial", "#FFFFFF");
		messageButtonText.textAlign = "center";
		messageButtonText.textBaseline = "middle";
		messageButtonText.x = 100 / 2;
		messageButtonText.y = 60 / 2;

		var messageButtonContainer = new createjs.Container();
		messageButtonContainer.name = name;
		messageButtonContainer.addChild(messageButtonBackground, messageButtonText);

		return messageButtonContainer;
	}

	var popupMessage = function(text)
	{
		var messageBackground = new createjs.Shape();
		messageBackground.graphics.beginFill("Blue").drawRoundRect(0, 0, 250, 400, 10);

		var messageText = new createjs.Text(text, "bold 24px Arial", "#FFFFFF");
		messageText.textAlign = "center";
		messageText.textBaseline = "middle";
		messageText.x = 250 / 2;
		messageText.y = 200;

		var messageContainer = new createjs.Container();
		messageContainer.x = window.innerWidth / 2 - 250 / 2;
		messageContainer.y = window.innerHeight / 2 - 400 / 2;

		var messageButtonContainer = generateButton("O.K.", "button");
		messageButtonContainer.x = 250 / 2 - 100 / 2;
		messageButtonContainer.y = 400 - 100;

		messageContainer.addChild(messageBackground, messageText, messageButtonContainer);

		return messageContainer;
	}

	var questionMessage = function(text)
	{
		var messageBackground = new createjs.Shape();
		messageBackground.graphics.beginFill("Blue").drawRoundRect(0, 0, 250, 400, 10);

		var messageText = new createjs.Text(text, "bold 24px Arial", "#FFFFFF");
		messageText.textAlign = "center";
		messageText.textBaseline = "middle";
		messageText.x = 250 / 2;
		messageText.y = 200;

		var messageContainer = new createjs.Container();
		messageContainer.x = window.innerWidth / 2 - 250 / 2;
		messageContainer.y = window.innerHeight / 2 - 400 / 2;

		var yesButtonContainer = generateButton("Ja", "yes");
		yesButtonContainer.x = 250 / 2 - 100 / 2;
		yesButtonContainer.y = 400 - 200;

		var noButtonContainer = generateButton("Nein", "no");
		noButtonContainer.x = 250 / 2 - 100 / 2;
		noButtonContainer.y = 400 - 100;

		messageContainer.addChild(messageBackground, messageText, yesButtonContainer, noButtonContainer);

		return messageContainer;
	}

	var addGameCourseToButton = function (button)
	{
		button.on("click", function () {
			if (check(gameField)) {
				winCounter++;

				// Points
				switch (currentDifficulty) {
					case DIFFICULTIES.EASY:
						points += 1;
						break;
					case DIFFICULTIES.MEDIUM:
						points += 2;
						break;
					case DIFFICULTIES.HARD:
						points += 3;
						break;
				}

				// Schwirigkeit wählen
				if (winCounter === 3) {
					winCounter = 0;
					switch (currentDifficulty) {
						case DIFFICULTIES.EASY:
							currentDifficulty = DIFFICULTIES.MEDIUM;
							break;
						case DIFFICULTIES.MEDIUM:
							currentDifficulty = DIFFICULTIES.HARD;
							break;
						case DIFFICULTIES.HARD:
							gameFinished = true;
							break;
					}
				}

				if (DEBUG >= DEBUG_LEVEL.DEBUG)
					console.log("Level: " + currentDifficulty + " Counter: " + winCounter);

				// Spiel zuende oder nicht
				if (winCounter === 3 && currentDifficulty === DIFFICULTIES.HARD || gameFinished) {
					// Popup Nachricht
					var message = popupMessage("Richtig\nDu hast " + points + " Punkte gewonnen.");
					stage.addChild(message);

					message.getChildByName("button").on("click", function () {
						resetMinigame();
						minigameWon(2);
						stage.removeChild(message);
					});
				} else {
					// Popup Nachricht
					var message = popupMessage("Gewonnen");
					stage.addChild(message);

					// Nach klick neuer level starten
					message.getChildByName("button").on("click", function () {
						// Pipes entfernen
						removeBitmapsFromStage(stage, bitmaps);

						// Neue daten Generieren
						gameField = generateGameField(currentDifficulty);
						bitmaps = gameFieldConvertToBitmap(gameField);

						// Daten hinzufügen
						setListenerToBitmap(bitmaps);
						addBitmapsToStage(stage, bitmaps);
						stage.removeChild(message);
					});
				}
			} else {
				gameFinished = true;
				var message = questionMessage("Falsch\nDu hast " + points + " Punkte gewonnen.\nLevel trozdem nochmal versuchen?");
				stage.addChild(message);
				message.getChildByName("yes").on("click", function () {
					stage.removeChild(message);
				});
				message.getChildByName("no").on("click", function () {
					resetMinigame();
					minigameLost(2);
					stage.removeChild(message);
				});
			}
		});
	}

	/*
	*   VAR
	*/

	var currentDifficulty = DIFFICULTIES.TUT;

	var gameField = generateGameField(currentDifficulty);
	var bitmaps = gameFieldConvertToBitmap(gameField);

	// Für den spielablauf
	var winCounter = 0;
	var gameFinished = false;
	var points = 0;

	/*
	*   INIT
	*/

	$(function()
	{


		$("#winMinigameButton").click(function () {
			minigameWon(2);
		});
		$("#loseMinigameButton").click(function () {
			minigameLost(2);
		});


		var loadQueue = new createjs.LoadQueue(true);
		loadQueue.loadFile(IMAGES.STRAIGHT);
		loadQueue.loadFile(IMAGES.CURVE);
		loadQueue.loadFile(IMAGES.ROTATE);

		// Correct size
		var canvas = document.getElementById("canvas");
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		// Handle window resize
		$(window).on("resize", function()
		{
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("Window resized to: " + window.innerWidth + " x " + window.innerHeight);
		});

		// Ladeanzeige
		var loadBar = new createjs.Shape();
		loadBar.graphics.beginFill("Grey").drawRect(250, 250, 0, 20);
		stage.addChild(loadBar);

		loadQueue.on("progress", function(e)
		{
			loadBar.graphics.beginFill("Grey").drawRect(250, 250, e.progress * 200, 20);
			if (e.progress === 1)
				stage.removeChild(loadBar);
		});

		// Starte die Animation
		loadQueue.on("complete", function()
		{
			createjs.Ticker.addEventListener("tick", tick);
			createjs.Ticker.setFPS(40);

			setListenerToBitmap(bitmaps);
			addBitmapsToStage(stage, bitmaps);
		});

		// Ladevorgang starten
		loadQueue.load();

		// Generate animated Background objects
		for (var i = 0; i < 10; i++)
		{
			var background = new createjs.Shape();
			background.graphics.beginFill("Grey").drawPolyStar(parseInt(300 - Math.random() * (window.innerWidth + 300)) + 300, parseInt(300 - Math.random() * (window.innerHeight + 300)) + 300, 600, 5, 0.2, parseInt(Math.random() * 360));
			background.alpha = Math.random();
			background.x = background.x + 600 / 2;
			background.y = background.y + 600 / 2;
			background.regX = 600 / 2;
			background.regY = 600 / 2;
			createjs.Tween.get(background, { loop: true })
				.to({ rotation: 360 }, parseInt(Math.random() * 20000) + 40000);
			stage.addChild(background);
		}

		// Generate animated Water objects
		var water = new Array(100);
		for (var i = 0; i < water.length; i++)
		{
			water[i] = new createjs.Shape();
			// drawPolyStar ( x  y  radius  sides  pointSize  angle )
			water[i].graphics.beginFill("DeepSkyBlue").drawPolyStar((window.innerWidth - parseInt(Math.random() * 150)), parseInt(Math.random() * window.innerHeight), 8, 5, 0.2, parseInt(Math.random() * 360));
			createjs.Tween.get(water[i], { loop: true })
				.to({ y: 500 }, parseInt(Math.random() * 100) + 1500);
			stage.addChild(water[i]);
		}

		// Add buttons
		var goButton = generateButton("Wasser marsch!", "goButton");
		goButton.x = window.innerWidth / 2 - 250 / 2;
		goButton.y = window.innerHeight - 60 * 1.5;
		stage.addChild(goButton);

		var exitButton = generateButton("Exit", "exitButton");
		exitButton.x = window.innerWidth - 120;
		exitButton.y = 20;
		stage.addChild(exitButton);

		// Exit action
		exitButton.on("click", function () {
			exitMinigame();
		});

		var tutButton = generateButton("Anleitung", "tutButton");
		tutButton.x = 20;
		tutButton.y = 20;
		stage.addChild(tutButton);

		// Tut Action
		tutButton.on("click", function()
		{
			var message = popupMessage("Drehe die Rohre mit einem Klick um eine Verbindung zwischen dem Wasserfall und dem Dorf der Wazels zu bauen.");
			stage.addChild(message);
			message.getChildByName("button").on("click", function()
			{
				stage.removeChild(message);
			});
		});

		// Add game course to button
		addGameCourseToButton(goButton);

		// Animation
		function tick()
		{
			// Pipe Animation
			for (var i = 0; i < bitmaps.length; i++)
				for (var j = 0; j < bitmaps[i].length; j++)
					if (bitmaps[i][j].pipe.getRotation() !== bitmaps[i][j].rotation)
					{
						bitmaps[i][j].rotation = bitmaps[i][j].rotation + 10;
						if (bitmaps[i][j].rotation === 360)
							bitmaps[i][j].rotation = 0;
					}
			// Update Stage
			stage.update();
		}
	});
</script>