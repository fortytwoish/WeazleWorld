<div id="minigame2">
	<canvas style="border: 3px solid black" id="canvas" width="800" height="500"></canvas>
</div>
<script type="text/javascript" src="../Resources/jquery-2.2.4.min.js"></script>
<script type="text/javascript" src="../Resources/preloadjs-0.6.2.min.js"></script>
<script type="text/javascript" src="../Resources/easeljs-0.8.2.min.js"></script>
<script type="text/javascript" src="../Resources/tweenjs-0.6.2.min.js"></script>
<button id="exitMinigameButton" style="margin:auto">Exit</button>
<button id="winMinigameButton" style="margin:auto">Win</button>
<button id="loseMinigameButton" style="margin:auto">Lose</button>

<script>
    $( "#exitMinigameButton" ).click( function ()
    {
        
        exitMinigame();
    } );
    $( "#winMinigameButton" ).click( function ()
    {
        resetMinigame();
        minigameWon( 2 );
    } );
    $( "#loseMinigameButton" ).click( function ()
    {
        resetMinigame();
        minigameLost( 2 );
    } );
    function resetMinigame(){}
	/*
	*   CONST
	*/

	var DIFFICULTIES = {
		TUT: [3, 3],
		EASY: [4, 4],
		MEDIUM: [5, 4],
		HARD: [7, 5]
	};

	var DEBUG_LEVEL = {
		OFF: 0,
		DEBUG: 1,
		VERBOSE: 2
	};
	var PIPE_TYPES = {
		STRAIGHT: 1,
		CURVE: 2
	};
	var IMAGES = {
		STRAIGHT: "/img/waterGame/STRAIGHT.png",
		CURVE: "/img/waterGame/CURVE.png",
		ROTATE: "/img/waterGame/rotate.gif"
	};

	var DEBUG = DEBUG_LEVEL.VERBOSE;

	var stage = new createjs.Stage("canvas");
	stage.enableMouseOver(10);

	/*
	*   OBJECTS
	*/

	var Pipe = function(type, targetRotation)
	{
		var typeLocal = type;
		var currentRotationLocal = (parseInt(Math.random() * 4) * 90);
		var targetRotationLocal = targetRotation;

		this.getType = function()
		{
			return typeLocal;
		}

		this.getImage = function()
		{
			switch (typeLocal)
			{
				case PIPE_TYPES.CURVE:
					return IMAGES.CURVE;
				case PIPE_TYPES.STRAIGHT:
					return IMAGES.STRAIGHT;
			}
			return IMAGES.ROTATE;
		}

		this.getRotation = function()
		{
			return currentRotationLocal;
		}

		this.isInCorrectPosition = function()
		{
			if (currentRotationLocal === targetRotationLocal ||
				targetRotationLocal === -1 ||
				typeLocal === PIPE_TYPES.STRAIGHT && currentRotationLocal === targetRotationLocal + 180)
				return true;
			return false;
		}

		this.turn = function()
		{
			if (currentRotationLocal < 270)
				currentRotationLocal += 90;
			else
				currentRotationLocal = 0;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("Rotate to: " + currentRotationLocal);
		}
	}

	var PIPES = {
		UPDOWN: new Pipe(PIPE_TYPES.STRAIGHT, 0),
		UPLEFT: new Pipe(PIPE_TYPES.CURVE, 0),
		RIGHTDOWN: new Pipe(PIPE_TYPES.CURVE, 180),
		RIGHTLEFT: new Pipe(PIPE_TYPES.STRAIGHT, 90)
	};

	/*
	*   LOCAL FUNCTIONS
	*/

	var gameFieldConvertToBitmap = function(gameField)
	{
		var x = 100;
		var y = 100;
		var pipeSize = 300 / gameField.length;
		var bitmaps = new Array(gameField.length);

		for (var i = 0; i < gameField.length; i++)
		{
			bitmaps[i] = new Array(gameField[i]);
			for (var j = 0; j < gameField[i].length; j++)
			{
				var bitmap = new createjs.Bitmap(gameField[i][j].getImage());
				bitmap.x = x + (j * pipeSize) + 50;
				bitmap.y = y + (i * pipeSize) + 50;
				bitmap.regX = 100;
				bitmap.regY = 100;
				bitmap.scaleX = 0.5;
				bitmap.scaleY = 0.5;
				bitmap.rotation = gameField[i][j].getRotation();
				bitmap.pipe = gameField[i][j];
				bitmaps[i][j] = bitmap;
			}
		}
		return bitmaps;
	}

	var rotater = new createjs.Bitmap(IMAGES.ROTATE);
	var setListenerToBitmap = function(bitmaps)
	{
		for (var i = 0; i < bitmaps.length; i++)
			for (var j = 0; j < bitmaps[i].length; j++)
			{
				bitmaps[i][j].on("click", function()
				{
					this.pipe.turn();
				});
				bitmaps[i][j].on("mouseover", function()
				{
					this.alpha = 0.5;
					rotater.x = this.x - 50;
					rotater.y = this.y - 50;
					rotater.scaleX = 0.1;
					rotater.scaleY = 0.1;
					stage.addChild(rotater);
				});
				bitmaps[i][j].on("mouseout", function(e)
				{
					this.alpha = 1;
					stage.removeChild(rotater);
				});
			}
	}

	var appendBitmapsToStage = function(stage, bitmaps)
	{
		for (var i = 0; i < bitmaps.length; i++)
			for (var j = 0; j < bitmaps[i].length; j++)
				stage.addChild(bitmaps[i][j]);
	}

	var generateGameField = function(size)
	{
		// Baut das Array auf
		var gameField = new Array(size[1]);
		for (var i = 0; i < gameField.length; i++)
		{
			gameField[i] = new Array(size[0]);
			for (var j = 0; j < gameField[i].length; j++)
				if (parseInt(Math.random() * 2) === 0)
					gameField[i][j] = new Pipe(PIPE_TYPES.CURVE, -1);
				else
					gameField[i][j] = new Pipe(PIPE_TYPES.STRAIGHT, -1);
		}

		if (DEBUG >= DEBUG_LEVEL.DEBUG)
			console.log("Array aufgebaut");

		// Zufälliger Weg
		if (parseInt(Math.random() * 2) === 0)
		{
			gameField[0][size[0] - 1] = PIPES.RIGHTDOWN;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("RIGHTDOWN " + 0 + " " + (size[0] - 1));
		} else
		{
			gameField[0][size[0] - 1] = PIPES.RIGHTLEFT;
			if (DEBUG >= DEBUG_LEVEL.VERBOSE)
				console.log("RIGHTLEFT " + 0 + " " + (size[0] - 1));
		}

		for (var i = 0, j = size[0] - 1; i < gameField.length - 1 || j > 0;)
			switch (gameField[i][j])
			{
				case PIPES.UPDOWN:
					if (i < gameField.length - 2)
						if (parseInt(Math.random() * 2) === 0)
							gameField[++i][j] = PIPES.UPDOWN;
						else
							gameField[++i][j] = PIPES.UPLEFT;
					else
						gameField[++i][j] = PIPES.UPLEFT;
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("UPDOWN " + i + " " + j);
					break;
				case PIPES.UPLEFT:
					if (j > 0)
						if (parseInt(Math.random() * 2) === 0)
							gameField[i][--j] = PIPES.RIGHTDOWN;
						else
							gameField[i][--j] = PIPES.RIGHTLEFT;
					else
						gameField[i][--j] = PIPES.RIGHTLEFT;
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("UPLEFT " + i + " " + j);
					break;
				case PIPES.RIGHTDOWN:
					if (i < gameField.length - 1)
						if (parseInt(Math.random() * 2) === 0)
							gameField[++i][j] = PIPES.UPDOWN;
						else
							gameField[++i][j] = PIPES.UPLEFT;
					else
					{
						console.log("Vor: " + i);
						gameField[++i][j] = PIPES.UPDOWN;
						console.log("Nach: " + i);
					}
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("RIGHTDOWN " + i + " " + j);
					break;
				case PIPES.RIGHTLEFT:
					if (j > 1)
						if (parseInt(Math.random() * 2) === 0)
							gameField[i][--j] = PIPES.RIGHTLEFT;
						else
							gameField[i][--j] = PIPES.RIGHTDOWN;
					else
						gameField[i][--j] = PIPES.RIGHTDOWN;
					if (DEBUG >= DEBUG_LEVEL.VERBOSE)
						console.log("RIGHTLEFT " + i + " " + j);
					break;
			}

		if (DEBUG >= DEBUG_LEVEL.DEBUG)
			console.log("Weg erzeugt");

		// Testausgabe row = zeile
		if (DEBUG >= DEBUG_LEVEL.VERBOSE)
		{
			console.log("Lösung");
			gameField.forEach(function(row)
			{
				var s = '[';
				row.forEach(function(col)
				{
					switch (col)
					{
						case PIPES.UPDOWN:
							s = s + ' ' + "|";
							break;
						case PIPES.UPLEFT:
							s = s + ' ' + "L";
							break;
						case PIPES.RIGHTDOWN:
							s = s + ' ' + "D";
							break;
						case PIPES.RIGHTLEFT:
							s = s + ' ' + "-";
							break;
						default:
							s = s + ' ' + " ";
							break;
					}
				});
				console.log(s + ' ]');
			});
		}

		return gameField;
	}

	var check = function(gameField)
	{
		for (var i = 0; i < gameField.length; i++)
			for (var j = 0; j < gameField[i].length; j++)
				if (!gameField[i][j].isInCorrectPosition())
					return false;
		return true;
	}

	/*
	*   INIT
	*/

	$(function()
	{
		var gameField = generateGameField(DIFFICULTIES.TUT);
		var bitmaps = gameFieldConvertToBitmap(gameField);

		var loadQueue = new createjs.LoadQueue(true);
		loadQueue.loadFile(IMAGES.STRAIGHT);
		loadQueue.loadFile(IMAGES.CURVE);
		loadQueue.loadFile(IMAGES.ROTATE);

		// Ladeanzeige
		var loadBar = new createjs.Shape();
		loadBar.graphics.beginFill("Grey").drawRect(250, 250, 0, 20);
		stage.addChild(loadBar);

		loadQueue.on("progress", function(e)
		{
			loadBar.graphics.beginFill("Grey").drawRect(250, 250, e.progress * 200, 20);
			if (e.progress === 1)
				stage.removeChild(loadBar);
		});

		// Starte die Animation
		loadQueue.on("complete", function()
		{
			createjs.Ticker.addEventListener("tick", tick);
			createjs.Ticker.setFPS(40);

			setListenerToBitmap(bitmaps);
			appendBitmapsToStage(stage, bitmaps);
		});

		// Ladevorgang starten
		loadQueue.load();

		// Generate animated Water objects
		var water = new Array(100);
		for (var i = 0; i < water.length; i++)
		{
			water[i] = new createjs.Shape();
			// drawPolyStar ( x  y  radius  sides  pointSize  angle )
			water[i].graphics.beginFill("DeepSkyBlue").drawPolyStar((parseInt(Math.random() * 150) + 550), parseInt(Math.random() * 500), 8, 5, 0.2, 10);
			createjs.Tween.get(water[i], { loop: true })
				.to({ y: 500 }, parseInt(Math.random() * 100) + 1500);
			stage.addChild(water[i]);
		}

		// Animation
		function tick()
		{
			// Pipe Animation
			for (var i = 0; i < bitmaps.length; i++)
				for (var j = 0; j < bitmaps[i].length; j++)
					if (bitmaps[i][j].pipe.getRotation() !== bitmaps[i][j].rotation)
					{
						bitmaps[i][j].rotation = bitmaps[i][j].rotation + 10;
						if (bitmaps[i][j].rotation === 360)
							bitmaps[i][j].rotation = 0;
					}
			// Update Stage
			stage.update();
		}
	});
</script>